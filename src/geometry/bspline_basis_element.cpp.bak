#include "geometry/bspline_basis_element.hpp"


/*!
 * Evaluates the B-spline basis function \f$ B_{i,p}(x) \f$, where \f$ p \f$
 * is the spline's degree, \f$ x \f$ is the evaluation point, and \f$ i \f$
 * is the index of the requested basis element.
 *
 * This implements algorithm A2.4 from the NURBS Book.
 */
real
BSplineBasisElement::operator()(
        real eval,
        int idx,
        const std::vector<real> &knots,
        unsigned int degree)
{
    // uppermost knot index:
    int m = knots.size() - 1;

    // handle special cases:
    if( idx == 0 && eval == knots[0]  )
    {
        return 1.0;
    }
    if( idx == m - degree - 1 && eval == knots[m] )
    {
        return 1.0;
    }

    // use local support property to simply return zeros:
    if( eval < knots[idx] || eval >= knots[idx + degree + 1] )
    {
        return 0.0;
    }

    // allocate memory for coefficients in triangle table:
    std::vector<real> coefs(degree + 1);

    // initialise degree zero basis functions (bottom of Cox-deBoor recursion):
    for(int i = 0; i <= degree; i++)
    {
        if( eval >= knots[idx + i] &&
            eval < knots[idx + i + 1] )
        {
            coefs[i] = 1.0;
        }
        else
        {
            coefs[i] = 0.0;
        }
    }

    // compute basis spline via triangular table:
    for(int i = 1; i <= degree; i++)
    {
        real saved;
        if( coefs[0] == 0.0 )
        {
            saved = 0.0;
        }
        else
        {
            saved = ((eval - knots[idx])*coefs[0])/(knots[idx+i] - knots[idx]);
        }

        for(int j = 0; j <= degree - i + 1; j++)
        {
            // knots to the left and right:
            real left = knots[idx + j + 1];
            real right = knots[idx + j + i + 1];

            // compute coefficients:
            if( coefs[j + 1] == 0.0 )
            {
                coefs[j] = saved;
                saved = 0.0;
            }
            else
            {
                real tmp = coefs[j + 1]/(right - left);
                coefs[j] = saved + (right - eval)*tmp;
                saved = (eval - left)*tmp;
            }
        }
    }

    // return value of basis function:
    return coefs[0];
}


/*
 *
 */
real
BSplineBasisElement::operator()(
        real eval,
        const std::vector<real> &knots,
        unsigned int degree,
        unsigned int idx,
        unsigned int deriv)
{
    // evaluate all derivatives up to degree deriv:
    std::vector<real> ders = evaluateDerivatives(
            eval,
            knots,
            degree,
            idx,
            deriv);

    // return only the requested derivativ:
    return ders[deriv];
}


/*
 *
 */
std::vector<real>
BSplineBasisElement::evaluateDerivatives(
        real eval,
        const std::vector<real> &knots,
        unsigned int degree,
        unsigned int idx,
        unsigned int deriv)
{
    // allocate memory for output vector:
    std::vector<real> ders(deriv + 1);

    // use local support property:
    if( (eval < knots[idx] || eval >= knots[idx + degree + 1]) )
    {
/*        std::cout<<"idx = "<<idx<<"  "
                 <<"degree = "<<degree<<"  "
                 <<"knots[idx + degree + 1] = "<<knots[idx + degree + 1]<<"  "
                 <<"knots.size = "<<knots.size()<<"  "
                 <<std::endl;*/

        for(int i = 0; i <= deriv; i++)
        {
            // NOTE: this if is missing in The NURBS Book, but is necessary
            // to handle the special case of the last basis function if the
            // evaluation point is identical to that knot
            if( eval == knots.back() && idx == knots.size() - degree - 2 )
            {
                ders[i] = 1.0;
            }
            else
            {
//                std::cout<<"bing"<<std::endl;                             
                ders[i] = 0.0;
            }
        }

        return ders;
    }

    // allocate memory for B-spline coefficients:
    std::vector<std::vector<real>> coefs(degree + 1, std::vector<real>(degree));

    // initialise degree zero basis functions (bottom of Cox-deBoor recursion):
    for(int i = 0; i <= degree; i++)
    {
        if( eval >= knots[idx + i] && eval < knots[idx + i + 1] )
        {
            coefs[i][0] = 1.0;
        }
        else
        {
            coefs[i][0] = 0.0;
        }
    }

    // compute all basis function coefficients via triangular table:
    for(int i = 1; i <= degree; i++ )
    {
        real saved;
        if( coefs[0][i - 1] == 0.0 )
        {
            saved = 0.0;
        }
        else
        {
            saved = ((eval - knots[idx])*coefs[0][i-1]) 
                    / (knots[idx+i] - knots[idx] );
        }

        for(int j = 0; j < degree - i + 1; j++)
        {
            // left and right knots:
            real left = knots[idx + j + 1];
            real right = knots[idx + j + i + 1];

            if( coefs[j + 1][i - 1] == 0.0 )
            {
                coefs[j][i] = saved;
                saved = 0.0;
            }
            else
            {
                real tmp = coefs[j + 1][i - 1] / (right - left);
                coefs[j][i] = saved + (right - eval)*tmp;
                saved = (eval - left)*tmp;
            }
        }
    }

    // copy function value to output vector:
    ders[0] = coefs[0][degree];
    // TODO: ders[0] seems to be correct! 
    std::cout<<"ders[0] = "<<ders[0]<<std::endl<<std::endl<<std::endl;
    

    std::cout<<"coefs = "<<std::endl;
    for(int i = 0; i < coefs.size(); i++)
    {
        for(int j = 0; j < coefs.at(i).size(); j++)
        {
            std::cout<<coefs[i][j]<<"\t";
        }
        std::cout<<std::endl;
    }


    // compute the derivatives:
    for(int k = 1; k <= deriv; k++)
    {
        //
        std::cout<<"copy loop"<<std::endl;
        std::vector<real> nd(k + 1);
        for(int i = 0; i <= k; i++)
        {
            nd[i] = coefs[i][degree - k];
            std::cout<<"k = "<<k<<"  "
                     <<"i = "<<i<<"  "
                     <<"nd[i] = "<<nd[i]<<"  "
                     <<std::endl;
        }

        //
        for(int i = 1; i <= k; i++)
        {
            // for efficiency, evaluate expression only if non-zero:
            real saved;
            if( nd[0] == 0.0 )
            {
                saved = 0.0;
            }
            else
            {
                saved = nd[0]/(knots[idx + degree - k + i] - knots[idx]);
            }
            std::cout<<"pre  loop"<<"  "
                     <<"k = "<<k<<"  "
                     <<"i = "<<i<<"  "
                     <<"nd[0] = "<<nd[0]<<"  "
                     <<"saved = "<<saved<<"  "
                     <<"k - i + 1 = "<<k - i + 1<<"  "
                     <<std::endl;

            //
            for(int j = 0; j < k - i + 1; j++)
            {
                // left and right knots:
                real left = knots[idx + j + 2];
                real right = knots[idx + j + degree + i + 1];

                std::cout<<"  j = "<<j<<"  "
                         <<"left = "<<left<<"  "
                         <<"right = "<<right<<"  "
                         <<"nd[j + 1] = "<<nd[j+1]<<"  "
                         <<"saved = "<<saved<<"  "
                         <<std::endl;


                if( nd[j + 1] == 0.0 )
                {
                    nd[j] = (degree - k + i)*saved;
                    saved = 0.0;
                    std::cout<<"    IF"<<"  "
                             <<"degree = "<<degree<<"  "
                             <<"k = = "<<k<<"  "
                             <<"i = "<<i<<"  "
                             <<"nd[j] = "<<nd[j]<<"  "
                             <<std::endl;
                }
                else
                {
                    // TODO: wrong values occur only if this ELSE is entered,
                    // but not always when it is entered. I suspect the error 
                    // is not caused here, but is caused by either wrong values
                    // being used or the if being entered falsely
                    //
                    // error only occurs if left = -4, i.e. leftmost knot value
                    real tmp = nd[j + 1]/(right - left);
                    nd[j] = (degree - k + i)*(saved - tmp);
                    saved = tmp;
                    std::cout<<"    ELSE"<<"  "
                             <<"degree = "<<degree<<"  "
                             <<"k = = "<<k<<"  "
                             <<"i = "<<i<<"  "
                             <<"tmp = "<<tmp<<"  "
                             <<"nd[j] = "<<nd[j]<<"  "
                             <<std::endl;
                }
            }
            std::cout<<"post loop"<<"  "
                     <<"k = "<<k<<"  "
                     <<"i = "<<i<<"  "
                     <<"nd[0] = "<<nd[0]<<"  "
                     <<"saved = "<<saved<<"  "
                     <<std::endl;
        }

        // copy k-th derivative to output vector:
        ders[k] = nd[0];
    }

    // return vector of derivatives up to order deriv:
    return ders;
}































